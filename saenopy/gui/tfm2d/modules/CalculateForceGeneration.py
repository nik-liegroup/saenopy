import matplotlib.pyplot as plt
from qtpy import QtCore, QtWidgets, QtGui
from saenopy.gui.common import QtShortCuts, QExtendedGraphicsView
from qimage2ndarray import array2qimage
import sys
import traceback
from PIL import Image, ImageDraw
from .PipelineModule import PipelineModule
from tifffile import imread
from saenopy.gui.common.gui_classes import CheckAbleGroup, QProcess, ProcessSimple
from .result import Result2D
from pyTFM.TFM_functions import TFM_tractions
from pyTFM.plotting import show_quiver
import numpy as np
from pyTFM.TFM_functions import strain_energy_points, contractillity
try:
    from scipy.ndimage import binary_fill_holes
except ImportError:
    from scipy.ndimage.morphology import binary_fill_holes
from pyTFM.grid_setup_solids_py import interpolation # a simple function to resize the mask


class ForceGeneration(PipelineModule):

    def __init__(self, parent=None, layout=None):
        super().__init__(parent, layout)
        self.parent = parent
        #layout.addWidget(self)
        #with self.parent.tabs.createTab("Forces") as self.tab:
        #    pass

        with QtShortCuts.QVBoxLayout(self) as layout:
            layout.setContentsMargins(0, 0, 0, 0)
            with CheckAbleGroup(self, "force generation", url="https://saenopy.readthedocs.io/en/latest/interface_solver.html#detect-deformations").addToLayout() as self.group:
                with QtShortCuts.QVBoxLayout():
                    self.label = QtWidgets.QLabel("draw a mask with the red color to select the area where deformations and tractions that are generated by the colony.").addToLayout()
                    self.label.setWordWrap(True)
                    self.input_button = QtShortCuts.QPushButton(None, "calculate force generation", self.start_process)

        self.setParameterMapping("force_gen_parameters", {})

    def valueChanged(self):
        if self.check_available(self.result):
            im = imread(self.result.reference_stack).shape
            #voxel_size1 = self.result.stacks[0].voxel_size
            #stack_deformed = self.result.stacks[0]
            #overlap = 1 - (self.input_element_size.value() / self.input_win.value())
            #stack_size = np.array(stack_deformed.shape)[:3] * voxel_size1 - self.input_win.value()
            #self.label.setText(
            #    f"""Overlap between neighbouring windows\n(size={self.input_win.value()}µm or {(self.input_win.value() / np.array(voxel_size1)).astype(int)} px) is choosen \n to {int(overlap * 100)}% for an element_size of {self.input_element_size.value():.1f}μm elements.\nTotal region is {stack_size}.""")
        else:
            self.label.setText("")

    def check_available(self, result):
        return result.tx is not None

    def check_evaluated(self, result: Result2D) -> bool:
        return result.tx is not None

    def tabChanged(self, tab):
        if self.tab is not None and self.tab.parent() == tab:
            if self.check_evaluated(self.result):
                im = imread(self.result.reference_stack)

                fig1, ax = show_quiver(self.result.tx, self.result.ty, cbar_str="tractions\n[Pa]")
                ax.set_position([0, 0, 1, 1])
                fig1.set_dpi(100)
                fig1.set_size_inches(im.shape[1] / 100, im.shape[0] / 100)
                plt.savefig("force.png")
                im = plt.imread("force.png")
                self.parent.draw.setImage(im*255)


    def process(self, result: Result2D, force_gen_parameters: dict): # type: ignore
        mask = binary_fill_holes(result.mask == 1)  # the mask should be a single patch without holes
        # changing the masks dimensions to fit to the deformation and traction fields
        mask = interpolation(mask, dims=result.u.shape)

        ps1 = result.pixel_size  # pixel size of the image of the beads
        # dimensions of the image of the beads
        ps2 = ps1 * np.mean(np.array(result.shape) / np.array(result.u.shape))  # pixel size of the deformation field

        # strain energy:
        # first we calculate a map of strain energy
        energy_points = strain_energy_points(result.u, result.v, result.tx, result.ty, ps1, ps2)  # J/pixel
        print(energy_points.shape)
        print("v", result.v.shape)
        print("u", result.u.shape)
        print("tx", result.tx.shape)
        print("ty", result.ty.shape)
        plt.imsave("strain_energy.png", energy_points)
        plt.imsave("mask.png", mask)
        # then we sum all energy points in the area defined by mask
        strain_energy = np.sum(energy_points[mask])  # 2.14*10**-13 J

        # contractility
        contractile_force, proj_x, proj_y, center = contractillity(result.tx, result.ty, ps2, mask)  # 2.03*10**-6 N

        print("strain energy", strain_energy)
        print("contractile force", contractile_force)
        print("projection", proj_x, proj_y)
        print("projection", proj_x.shape, np.unique(proj_x), proj_y.shape, np.unique(proj_y))
        print("center", center)

        result.save()

